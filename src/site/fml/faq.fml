<?xml version="1.0" encoding="UTF-8"?>
<faqs   xmlns="http://maven.apache.org/FML/1.0.1"
        xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
        xsi:schemaLocation="http://maven.apache.org/FML/1.0.1 http://maven.apache.org/xsd/fml-1.0.1.xsd"
        title="Frequently Asked Questions"
        toplink="false">
    <part id="file">
        <title>TrueZIP File* module</title>
        <faq id="cannotReadArchive">
            <question>
                When trying to read an archive file, I get an exception saying
                I cannot read directories.
                What's wrong?
            </question>
            <answer>
                <p>
                    When configured correctly, the File* API will treat an
                    archive file like a virtual directory (that's what TrueZIP
                    is all about).
                    Like with plain directories, applications cannot read or
                    write virtual directories using an input or output stream.
                </p>
                <p>
                    Use one of the 
                    <code>list*(*)</code> methods in the
                    <code>TFile</code> class instead.
                </p>
                <p>
                    For example, to list the contents of the top level
                    (virtual) directory of the archive file
                    <code>archive.zip</code>, you could use...
                </p>
                <source>TFile[] entries = new TFile("archive.zip").listFiles();</source>
            </answer>
        </faq>
        <faq id="cannotWriteArchive">
            <question>
                When trying to write an archive file, I get an exception saying
                I cannot write directories.
                What's wrong?
            </question>
            <answer>
                <p>
                    When configured correctly, the File* API will treat an
                    archive file like a virtual directory (that's what TrueZIP
                    is all about).
                    Like with plain directories, applications cannot read or
                    write virtual directories using an input or output stream.
                </p>
                <p>
                    Use one of the 
                    <code>mkdir*(*)</code> methods in the
                    <code>TFile</code> class or directly write to the entry
                    within the archive file using a
                    <code>TFileOutputStream</code> instead.
                    For example, to (over)write the entry 
                    <code>entry</code> within the archive file
                    <code>archive.zip</code>, you could use...
                </p>
<source>
OutputStream out = new TFileOutputStream("archive.zip/entry");
try {
    ... // write something here
} finally {
    out.close();
}
</source>
                <p>
                    This would work even if
                    <code>archive.zip</code> would not initially exist unless
                    <code>TFile.setLenient(false)</code> had been called by
                    your application before.
                    In this case, you would need to create the archive file
                    <code>archive.zip</code> in advance by using...
                </p>
                <source>new TFile("archive.zip").mkdir(false);</source>
            </answer>
        </faq>
        <faq id="cannotCopyFileToArchive">
            <question>
                Copying a file to an archive file does not seem to work.
                What's wrong?
            </question>
            <answer>
                <p>
                    Users often assume that when copying a file to an archive
                    file, the File* API would automatically complete the path
                    name of the destination archive file so that it ends with
                    the base name of the source file.
                    This is probably assumed because that's how it works with
                    command line utilities like 
                    <code>cp</code> on POSIX or
                    <code>copy</code> on Windows.
                    However, this is not true:
                    The File* API does 
                    <em>never</em> do path name completion.
                    Hence, the following code may behave unexpectedly:
                </p>
<source>
TFile src = new TFile(string1); // e.g. "file"
TFile dst = new TFile(string2); // e.g. "archive.zip"
src.cp_rp(dst);
</source>
                <p>
                    If successful, this would only result in a verbatim copy of 
                    <code>file</code> to 
                    <code>archive.zip</code>, which is probably unexpected.
                    However, the way the copy command line utilities work can
                    be easily emulated by using the following instead:
                </p>
<source>
TFile src = new TFile(string1); // e.g. "file"
TFile dst = new TFile(string2); // e.g. "archive.zip"
if (TFile.isLenient() &amp;&amp; dst.isArchive() || dst.isDirectory())
    dst = new TFile(dst, src.getName());
src.cp_rp(dst);
</source>
                <p>
                    This will append the base name of the source path to the
                    destination path if either the destination path name ends
                    with a recognized archive file suffix like e.g. ".zip" or
                    if the destination file system entry already exists as a
                    directory.
                    If 
                    <code>TFile.setLenient(false)</code> is never called by
                    your application, then you could shorten this to...
                </p>
<source>
TFile src = new TFile(string1); // e.g. "file"
TFile dst = new TFile(string2); // e.g. "archive.zip"
if (dst.isArchive() || dst.isDirectory())
    dst = new TFile(dst, src.getName());
src.cp_rp(dst);
</source>
                <p>
                    If you don't like path name completion for non-existent
                    files which just look like archive files according to their
                    file name, then you could even shorten this to...
                </p>
<source>
TFile src = new TFile(string1); // e.g. "file"
TFile dst = new TFile(string2); // e.g. "archive.zip"
if (dst.isDirectory())
    dst = new TFile(dst, src.getName());
src.cp_rp(dst);
</source>
            </answer>
        </faq>
        <faq id="cannotListArchive">
            <question>
                The API is not treating an archive file as a virtual directory.
                What's wrong?
            </question>
            <answer>
                <p>
                    Most likely the TrueZIP File* module is not set up
                    correctly in order to detect the file suffix of the archive
                    type you want to access.
                    To make sure it does, call the following somewhere at the
                    start of your application:
                </p>
<source>
TFile.setDefaultArchiveDetector(
        new TArchiveDetector(
            TArchiveDetector.NULL,
            new Object[][] {
                { "tar", new TarDriver(IOPoolLocator.SINGLETON) },
                { "tgz|tar.gz", new TarGZipDriver(IOPoolLocator.SINGLETON) },
                { "tbz|tb2|tar.bz2", new TarBZip2Driver(IOPoolLocator.SINGLETON) },
                { "zip", new ZipDriver(IOPoolLocator.SINGLETON)},
            }));
</source>
                <p>
                    Check the
                    <a href="kick-start/index.html">Maven Archetypes</a> for more
                    options and to help you get started quickly with this.
                </p>
            </answer>
        </faq>
        <faq id="corruptedArchive">
            <question>
                When I create or update archive entries,
                the modified archive file gets corrupted.
                What's wrong?
            </question>
            <answer>
                <p>
                    The TrueZIP Kernel module applies advanced caching
                    strategies for archive entries.
                    So whenever you create or update archive entries, your
                    changes need to get committed to the archive file when
                    you're done.
                    On certain events, e.g. whenever the JVM terminates
                    normally (i.e. doesn't crash), this happens automatically.
                    However, in a long running application you may want to do
                    this manually in order to allow <i>third parties</i> to
                    access the archive file.
                    The term <i>third party</i> in this context includes any
                    other OS process and even the legacy java.io.File* API.
                </p>
                <p>
                    Committing any unsynchronized changes to all archive files
                    is easy - just call...
                </p>
                <source>TFile.umount();</source>
                <p>
                    Please have a look at the method's
                    <a href="apidocs/de/schlichtherle/truezip/file/TFile.html#umount()">Javadoc</a>
                    for more options.
                </p>
            </answer>
        </faq>
        <faq id="http">
            <question>
                How can I access an archive file via HTTP(S)?
            </question>
            <answer>
                <p>
                    The TrueZIP File* API supports only file based URIs.
                    To access an archive file via HTTP(S) or any other
                    scheme, you need to use the TrueZIP Kernel API instead.
                    There's a <a href="truezip-samples/kernel-usage.html">Usage</a>
                    article with samples in the
                    <a href="truezip-samples/index.html">TrueZIP Samples</a>
                    module.
                </p>
            </answer>
        </faq>
        <faq id="accessAbsoluteEntryName">
            <question>
                How can I access entries with absolute entry names in archive
                files?
            </question>
            <answer>
                <p>
                    You can't because there is no addressing scheme for this.
                    For example, the expression
                    <code>new TFile("archive.zip/entry")</code> gets decomposed
                    into the file system path <code>archive.zip</code> as the
                    mount point of the archive file and the relative entry name
                    <code>entry</code> as the entry name within this archive
                    file.
                    There's no expression to address the absolute entry name
                    <code>/entry</code> within the archive file instead.
                    Even if you would try
                    <code>new TFile("archive.zip//entry")</code>, it would
                    just get normalized to the previous expression.
                </p>
                <p>
                    See also <a href="#manageAbsoluteEntryName">here</a>.
                </p>
            </answer>
        </faq>
    </part>
    <part id="general">
        <title>General Questions</title>
        <faq id="whereAreNews">
            <question>Where are the latest News?</question>
            <answer>
                <p>
                    Starting from version 7.0, the TrueZIP project has it's
                    own blog for announcements, release notes, feature show
                    cases and more named
                    <a href="http://truezip.schlichtherle.de">The TrueZIP Blog</a>.
                </p>
            </answer>
        </faq>
        <faq id="no-maven">
            <question>Do I have to use Maven to use TrueZIP?</question>
            <answer>
                <p>
                    Absolutely not!
                    To learn about your options, please read the article
                    <a href="kick-start/no-maven.html">Using TrueZIP Without Maven</a>.
                </p>
            </answer>
        </faq>
        <faq id="whereIsJavadoc">
            <question>Where is the Javadoc?</question>
            <answer>
                <p>
                    You can find the Javadoc for the entire TrueZIP API
                    including all modules in the navigation bar by clicking
                    <i>Project Reports</i> -> <i>Project Reports</i> ->
                    <i>JavaDocs</i>, or you could simply click
                    <a href="apidocs/index.html">here</a>.
                </p>
            </answer>
        </faq>
        <faq id="binaryCompatibility">
            <question>
                How does TrueZIP deal with binary compatibility?
            </question>
            <answer>
                <p>
                    TrueZIP uses the same version numbering scheme like Maven,
                    i.e.
                    <code>&lt;major&gt;.&lt;minor&gt;.&lt;incremental&gt;-&lt;qualifier&gt;</code>.
                    Within the same major version number, binary compatibility
                    should be retained so that recompilation of a client
                    application should not be necessary.
                </p>
                <p>
                    However, there is one exception:
                    Binary compatibility may be broken in a subsquent release
                    if all of the following conditions apply:
                </p>
                <ol>
                <li>A feature's design is broken.</li>
                <li>The feature is assumed to be rarely used by client
                    applications or the implications of not changing it are
                    considered to be unacceptable.</li>
                <li>This issue is documented as a ticket in the project's
                    <a href="http://java.net/jira/browse/TRUEZIP">Issue Tracking System</a>
                    (ITS) with the tag <code>binary-compatibility</code>.</li>
                <li>A workaround is explained in the ITS ticket.</li>
                <li>The ITS ticket is referenced in the Release Notes.</li>
                </ol>
                <p>
                    In case your client application is affected by a change and
                    the documented workaround is unacceptable for any reason,
                    please address this using the ITS at
                    <a href="http://java.net/jira/browse/TRUEZIP">http://java.net/jira/browse/TRUEZIP</a>.
                </p>
            </answer>
        </faq>
        <faq id="manageAbsoluteEntryName">
            <question>
                How does TrueZIP deal with entries with absolute entry names in
                archive files?
            </question>
            <answer>
                <p>
                    As answered <a href="#accessAbsoluteEntryName">here</a>,
                    you cannot access entries with absolute entry names in
                    archive files.
                    This implies that you cannot create archive files which
                    contain entries with absolute entry names.
                </p>
                <p>
                    However, you can use TrueZIP to read, modify or delete
                    archive files which contain entries with absolute entry
                    names:
                    If you use TrueZIP to modify an archive file which
                    contains entries with absolute entry names, these entry 
                    names are preserved.
                    Likewise, an archive file can get deleted like any empty
                    directory if it contains only entries with absolute entry
                    names.
                </p>
            </answer>
        </faq>
        <faq id="normalizeEntryName">
            <question>
                How does TrueZIP deal with entries with dot <code>"."</code>
                or dot-dot <code>".."</code> segments in archive files?
            </question>
            <answer>
                <p>
                    Wherever possible, redundant segments are removed by a
                    normalization of the entry name
                    before the corresponding archive entry is mounted into the
                    file system.
                    When updating the archive file however, the original
                    archive entry name is preserved.
                    If a dot-dot segment remains at the start of the entry name,
                    the corresponding entry will not be accessible by the
                    application, but preserved with its original entry name
                    upon an update of its archive file.
                </p>
            </answer>
        </faq>
        <faq id="manageWindowsSeparator">
            <question>
                How does TrueZIP deal with entries which use <code>"\"</code>
                as the separator character in archive files?
            </question>
            <answer>
                <p>
                    Any occurence of this illegal separator character is
                    replaced by the correct separator character <code>"/"</code>
                    before the entry name is
                    <a href="#normalizeEntryName">normalized</a> and the
                    corresponding archive entry is mounted into the file system.
                    When updating the archive file however, the original
                    archive entry name is preserved.
                </p>
            </answer>
        </faq>
        <faq id="manageDuplicateEntry">
            <question>
                How does TrueZIP deal with duplicate entries in archive files?
            </question>
            <answer>
                <p>
                    If, after
                    <a href="#normalizeEntryName">normalization</a> of the entry name,
                    two or more entries in an archive file are sharing an equal
                    entry name, only the last archive entry will get mounted
                    into the archive file system.
                </p>
                <p>
                    Some archive file formats, e.g. ZIP and TAR, use a trailing
                    slash <code>'/'</code> character to indicate a directory
                    entry.
                    In case an archive file contains two entries which, after
                    normalization of their name, differ only in a trailing
                    slash, then a hybrid entry is mounted into the file system.
                    This hybrid entry will be accessible as if it were both a
                    file and a directory entry at the same time, e.g. you
                    can read and write its content and you can list or change
                    its members.
                </p>
            </answer>
        </faq>
        <faq id="nestedArchiveCompression">
            <question>
                How does TrueZIP deal with the compression of nested archive
                files like e.g. <code>app.war/WEB-INF/lib/lib.jar</code>?
            </question>
            <answer>
                <p>
                    With the advent of release 7.1, TrueZIP implements a new
                    strategy to avoid compressing already compressed archive
                    files in an enclosing archive file again.
                    In contrast, the old stragegy of TrueZIP 7.0 and earlier
                    was to compress everything - even if it was already
                    compressed.
                </p>
                <p>
                    The new strategy results in a better overall compression
                    ratio than the old strategy because compressing already
                    compressed data again just inflates the data a bit because
                    of some algorithm specific overhead.
                </p>
                <p>
                    For the example in the question, the new strategy uses the
                    DEFLATE method to compress the entries of the inner archive
                    file <code>lib.jar</code> while it uses the STORE method
                    for the corresponding entry <code>WEB-INF/lib/lib.jar</code>
                    within the outer archive file <code>app.war</code>.
                    This behavior is in conformance to the JEE specs.
                </p>
                <p>
                    The new strategy is implemented by the archive drivers, so
                    it works best with all supported archive types.
                    For example, when storing a TAR file within a ZIP file,
                    the ZIP entry for the TAR file would use the DEFLATE
                    method because the TAR driver knows that plain TAR
                    files are not compressed.
                    In contrast, when storing a TAR.GZ file within a ZIP file,
                    the ZIP entry for the TAR.GZ file would use the STORE
                    method because the TAR.GZ driver knows that TAR.GZ
                    files are already compressed.
                </p>
            </answer>
        </faq>
        <faq id="support">
            <question>
                I have another question or issue.
                How do I get it responded and resolved?
            </question>
            <answer>
                <p>
                    For any bug report, improvement request, feature request,
                    task request, help request etc. please
                    <a href="mailto:users@truezip.java.net">post</a>
                    it to the User Mailing List once you have
                    <a href="mailto:sympa@truezip.java.net?subject=subscribe%20users">subscribed</a>
                    to it.
                    The User Mailing List is your direct connection to the
                    community.
                    My response time is usually less than a day - without
                    warranties!
                </p>
                <p>
                    Once your question or issue has been approved as a bug
                    report, improvement request, feature request or task
                    request it gets tracked in
                    <a href="http://java.net/jira/browse/TRUEZIP">JIRA</a>.
                    You can then use JIRA to monitor and discuss its progress,
                    vote for it, add file attachments to it etc.
                    JIRA is now also used to schedule new TrueZIP versions and
                    prepare their Release Notes.
                </p>
            </answer>
        </faq>
    </part>
</faqs>
