    -----------------------
    Use Cases
    -----------------------
    Christian Schlichtherle
    -----------------------

Software Build Tool (SBT)

    Suppose you're writing a plug-in for the next generation Software Build
    Tool which shall create assemblies of all project artifacts.

    Then, by a unique combination of hard-working and clever-thinking you may
    figure you'ld need to create assemblies of at least the following archive
    file types:

    * TAR.GZ

    * TAR.BZ2

    * ZIP

    * JAR

    * WAR

    * EAR

    * ...

    []

    You can imagine that writing the code to create archive file formats of all
    these types will be a cumbersome and tedious task because each archive file
    type comes with its own classes to read and create them.

    Now, with the API of the {{{./truezip-file/index.html}TrueZIP File*}}
    module, it's dead simple.
    Here's an example:

+-------------------------------------------------------------------+
new TFile("directory").archiveCopyAllTo(new TFile("archive.tar.gz"));
+-------------------------------------------------------------------+

    The
    {{{./apidocs/de/schlichtherle/truezip/file/TFile.html}<<<TFile>>>}}
    class extends the <<<File>>> class to add the functionality required to
    make such tasks simple.

    Note that in case of an I/O error, the boolean method
    {{{./apidocs/de/schlichtherle/truezip/file/TFile.html#archiveCopyAllTo(java.io.File)}<<<TFile.archiveCopyAllTo(*)>>>}}
    simply returns <<<false>>>.
    This was designed to be consistent with most methods in <<<java.io.File>>>.
    However, getting an <<<IOException>>> for diagnosis is much better, hence
    you could use the static void method
    {{{./apidocs/de/schlichtherle/truezip/file/TFile.html#cp_rp(java.io.File, java.io.File)}<<<TFile.cp_rp(*)>>>}}
    for the same task instead:

+-------------------------------------------------------------------+
TFile.cp_rp(new TFile("directory"), new TFile("archive.tar.gz"));
+-------------------------------------------------------------------+

    The name of this method is modeled after the Unix command line <<<cp -rp>>>.
    
    The type of the prospective archive file is detected by its
    suffix in the path name.
    In this case <<<.tar.gz>>> was used, but you could use any other
    configured archive file suffix, too.
    Configuration is easy - just add the JAR for the desired archive driver
    to the application's run time class path.
    This will configure the {{{./truezip-file/index.html}TrueZIP File*}} module
    to detect the canonical file suffixes of the archive file format
    implemented by the driver.
    
    For example, adding the artifact ID <<<truezip-driver-tar>>> as a
    dependency to the POM of your Maven build would configure the file suffixes
    <<<.tar>>>, <<<.tar.gz>>>, <<<.tgz>>>, <<<.tar.bz2>>> and <<<.tbz2>>> to
    be recognized for TAR files.

    In case you want a <<<TFile>>> object to recognize a different set of
    archive file suffixes then the ones enumerated on the run time class
    path, you could directly inject a
    {{{./apidocs/de/schlichtherle/truezip/file/TArchiveDetector.html}<<<TArchiveDetector>>>}}
    instance to the constructor of the <<<TFile>>> object instead like so:

+------------------------------------------------------------------+
TFile file = new TFile("archive.zip", TDefaultArchiveDetector.NULL);
+------------------------------------------------------------------+

    In this example, <<<TDefaultArchiveDetector.NULL>>> has been used to
    suppress the detection of any archive file suffixes.
    In case you need the opposite, you could inject
    <<<TDefaultArchiveDetector.ALL>>> instead.

Integrated Development Environment (IDE)

    Suppose you're writing a plug-in for then next generation Integrated
    Development Environment which shall show the users the contents of any
    assembly and allow them to arbitrarily modify it.

    Again you realize that you would need to write a lot of code to read all
    types of archive files just to list their contents.
    And considering the state transitions and algorithms required to support
    arbitrary modifications of an archive file may be a frightening thought.

    Now, with the API of the {{{./truezip-file/index.html}TrueZIP File*}}
    module, here's your relief:
    To list the contents of the root directory of an archive file, you could
    simply use:

+------------------------------+
new TFile("archive.jar").list();
+------------------------------+

    To overwrite an entry in an archive file, you could simply use:

+---------------------------------------------------------------------------+
OutputStream out = new TFileOutputStream("archive.jar/META-INF/MANIFEST.MF");
try {
    // ...
} finally {
    out.close(); // ALWAYS close the stream!
}
+---------------------------------------------------------------------------+

    To delete an entry in an archive file, you could simply use:

+----------------------------------------------------------+
if (!new TFile("archive.jar/META-INF/MANIFEST.MF").delete())
    throw new IOException("Oh s..t!");
+----------------------------------------------------------+

    You may be glad to know that this works recursively, too.
    Here's how to read the manifest of a library JAR within a web
    application:

+----------------------------------------------------------------------+
Reader in = new TFileReader("app.war/lib/lib.jar/META-INF/MANIFEST.MF");
try {
    // ...
} finally {
    in.close(); // ALWAYS close the stream!
}
+----------------------------------------------------------------------+

Application File Format

    Suppose you're writing a plug-in for the next generation application
    which shall use an archive file format with a custom file suffix as a
    container for some application data.

    Then, wouldn't it be nice if you wouldn't need to worry about how to read
    or write the archive file?
    You've already seen how to do this with the API of the
    {{{./truezip-file/index.html}TrueZIP File*}} module in the examples above.
    However, your application may need to recognize only your custom file
    suffixes "foo" or "bar" and nothing else.

    Here's how to register custom archive file suffixes for an instance of the
    JAR archive driver:

+-------------------------------------------------+
TFile.setDefaultArchiveDetector(
    new TDefaultArchiveDetector(
        "foo|bar",
        new JarDriver(IOPoolLocator.SINGLETON)));
+-------------------------------------------------+

    Once this has been called, any new <<<TFile>>> object will recognize only
    the <<<".foo">>> and <<<".bar">>> file suffixes by default
    - whereby case is ignored - and use the JAR file format to read or write
    these files.

    Note that TrueZIP recognizes false positive archive files, so it cannot
    get confused by an arbitrary file which inadvertenly uses a suffix of
    a supported archive file type.

    Please also note the usage of the class
    {{{./apidocs/de/schlichtherle/truezip/fs/archive/zip/JarDriver.html}<<<JarDriver>>>}}
    for using the JAR file format.
    The JAR file format is typically the best choice for custom application
    file formats because it supports compression, fast access and UTF-8 encoded
    entry names for maximum interoperability.
    In particular, the last point makes it superior to the ZIP file format.

Encrypted Application File Format

    Suppose you're still writing a plug-in for the next generation application,
    but this time you want to make sure that nobody can read or modify the
    contents of the custom file format aside from the application.

    Then, you would need lots of code for writing, reading and authenticating
    your custom encrypted archive file type.
    In case you would like to prompt the user for a password using a Swing
    GUI or the console, even more code would be required.

    Well, you guessed it: You don't need to write all this code with TrueZIP.
    Here's how to register custom archive file suffixes for an instance of the
    TZP archive driver:

+-------------------------------------------------+
TFile.setDefaultArchiveDetector(
    new TDefaultArchiveDetector(
        "fox|bax",
        new SafeZipRaesDriver(  IOPoolLocator.SINGLETON,
                                KeyManagerLocator.SINGLETON)));
+-------------------------------------------------+

    The class
    {{{./apidocs/de/schlichtherle/truezip/fs/archive/zip/raes/SafeZipRaesDriver.html}<<<SafeZipRaesDriver>>>}}
    is one of two available archive driver implementations for TrueZIP's
    custom encrypted ZIP.RAES (or TZP for short) file format.
    A TZP file is a ZIP file with UTF-8 encoded entry names (like the JAR file
    format) which is wrapped in a RAES file envelope.
    RAES is TrueZIP's custom Random Access Encryption Specification which
    supports SHA-256 authentication and AES-256 decryption in CTR block
    mode for transparent, read/write access to its encrypted payload.
    By using CTR mode, RAES supports transparent <random> read access to
    its encrypted payload, which makes reading a TZP file pretty fast.

    Note the injection of the
    {{{./apidocs/de/schlichtherle/truezip/key/sl/KeyManagerLocator.html#SINGLETON}<<<KeyManagerLocator.SINGLETON>>>}}
    into the <<<SafeZipRaesDriver>>>.
    This object is responsible for prompting the user for passwords.
    It will check if the JVM is in headless mode and then use the console for
    prompting, otherwise a Swing GUI.
    If you want to hard code a password instead, you would need to inject an
    instance of your own implementation of the interface
    {{{./apidocs/de/schlichtherle/truezip/key/KeyManagerProvider.html}<<<KeyManagerProvider>>>}}.
    For more information, please refer to the article about
    {{{./truezip-samples/key-management.html}Key Management}}.
